# 급여처리 시스템 구조 정리

## 📋 목차
1. [전체 흐름도](#전체-흐름도)
2. [Firestore 컬렉션 구조](#firestore-컬렉션-구조)
3. [컴포넌트 구조](#컴포넌트-구조)
4. [데이터 흐름](#데이터-흐름)
5. [주요 계산 로직](#주요-계산-로직)
6. [문제점 및 개선방향](#문제점-및-개선방향)

---

## 🔄 전체 흐름도

```
1. 스케줄 입력 (ScheduleInputNew.tsx)
   └─> schedules 컬렉션에 저장

2. 근무시간 비교 (WorkTimeComparison.tsx)
   ├─> schedules에서 예정근무시간 조회
   ├─> 실제 근무시간 입력
   └─> workTimeComparisonResults에 저장
       (상태: time_match, review_required, review_completed)

3. 지점별 검토완료 (WorkTimeComparison.tsx)
   └─> employeeReviewStatus 업데이트 (검토완료)

4. 직원별 급여처리 (EmployeePayrollProcessing.tsx)
   ├─> 근무시간비교 화면 (WorkTimeComparison)
   └─> 급여계산 화면 (PayrollCalculation)
       ├─> workTimeComparisonResults에서 실근무시간 조회
       ├─> employmentContracts에서 계약정보 조회
       ├─> employees에서 직원정보 조회
       ├─> 급여 계산 (수습, 주휴수당, 4대보험, 세금)
       └─> 급여확정 시 confirmedPayrolls에 저장

5. 세무사 전송파일 생성 (TaxFileGeneration.tsx)
   └─> confirmedPayrolls에서 확정된 급여 조회
```

---

## 🗄️ Firestore 컬렉션 구조

### 1. `employees` - 직원 기본정보
**용도**: 직원의 기본 정보 저장 (이름, 연락처, 은행정보, 수습정보 등)

```typescript
{
  id: string;                    // 문서 ID (자동생성)
  name: string;                  // 직원명
  phone?: string;                // 전화번호
  email?: string;                // 이메일
  residentNumber?: string;       // 주민번호 (뒷자리 암호화 권장)
  hireDate?: Date;               // 입사일
  resignationDate?: Date;        // 퇴사일 (null이면 재직중)
  
  // 은행정보
  bankName?: string;             // 은행명
  bankCode?: string;             // 은행코드
  accountNumber?: string;        // 계좌번호
  accountHolder?: string;        // 예금주명
  
  // 수습기간 관리
  probationStartDate?: Date;     // 수습 시작일
  probationEndDate?: Date;       // 수습 종료일
  probationPeriod?: number;      // 수습기간 (개월, 기본값 3)
  isOnProbation?: boolean;       // 현재 수습 중 여부
  
  // 메모
  memo?: string;                 // 직원 메모
  
  // 스케줄 노출 여부
  hideFromSchedule?: boolean;    // true면 스케줄 관리 화면에서 숨김
  
  createdAt: Date;
  updatedAt: Date;
}
```

**주의사항**:
- `resignationDate`가 있으면 퇴사자로 간주
- `hideFromSchedule`가 true인 월급 직원은 근무시간비교 없이 급여계산 가능
- 수습기간 정보는 여기 저장되지만, 실제 급여계산 시 employmentContracts의 정보가 우선

---

### 2. `employeeBranches` - 직원-지점 관계
**용도**: 한 직원이 여러 지점에서 근무 가능하도록 N:N 관계 관리

```typescript
{
  id: string;                    // 문서 ID
  employeeId: string;            // 직원 ID
  branchId: string;              // 지점 ID
  createdAt: Date;
}
```

**주의사항**:
- 직원 추가 시 반드시 최소 1개 이상의 지점 관계 생성 필요
- 직원 삭제 시 관련 employeeBranches도 함께 삭제 필요

---

### 3. `branches` - 지점정보
**용도**: 지점 기본 정보

```typescript
{
  id: string;                    // 문서 ID
  name: string;                  // 지점명 (예: "청담장어마켓 동탄점")
  companyName?: string;          // 회사명
  ceoName?: string;              // 대표자명
  businessNumber?: string;       // 사업자번호
  address?: string;              // 주소
  phone?: string;                // 전화번호
  managerEmails?: string[];      // 매니저 이메일 목록
  createdAt: Date;
  updatedAt: Date;
}
```

---

### 4. `employmentContracts` - 근로계약서 (히스토리)
**용도**: 직원의 근로계약 정보 히스토리 관리 (고용형태, 급여형태, 급여액 등)

```typescript
{
  id: string;                    // 문서 ID
  employeeId: string;            // 직원 ID
  employeeName: string;          // 직원명 (denormalized)
  
  // 고용정보
  employmentType: string;        // '근로소득' | '사업소득' | '일용직' | '외국인'
  salaryType: string;            // 'hourly' | 'monthly' (시급/월급)
  salaryAmount: number;          // 시급 또는 월급액
  
  // 근무조건
  weeklyWorkHours?: number;      // 주간 근무시간 (기본 40시간)
  includeHolidayAllowance?: boolean; // 주휴수당 포함 여부 (시급에 주휴수당이 이미 포함되어있는지)
  
  // 계약기간
  startDate: Date;               // 계약 시작일
  endDate?: Date;                // 계약 종료일 (없으면 현재 유효)
  
  // 계약서 파일
  contractFile?: string;         // Base64 또는 Firebase Storage URL
  contractFileName?: string;     // 파일명
  fileType?: string;             // 파일 타입
  fileSize?: number;             // 파일 크기
  isBase64?: boolean;            // Base64 저장 여부
  
  createdAt: Date;
  updatedAt: Date;
}
```

**⚠️ 중요 설계 - 수습기간 정보 위치**:
- **수습기간 정보는 `employees` 컬렉션에 저장됨** (probationStartDate, probationEndDate, probationPeriod)
- **이유**: 
  - 재입사 케이스가 없으므로 직원당 수습기간은 1회뿐
  - `employmentContracts`로 관리하는 것보다 단순하고 직관적
  - 급여계산 시 직원 정보에서 직접 조회 가능

**중요 로직**:
- 급여계산 시 `selectedMonth`에 유효한 계약서를 찾아야 함
  - `startDate <= monthEnd && (endDate == null || endDate >= monthStart)`
- 한 직원이 여러 개의 계약서를 가질 수 있음 (기간별로)
- **수습기간 계산**: 현재는 `employees` 컬렉션의 probationStartDate ~ probationEndDate를 사용하여 해당 기간의 근무시간에 급여의 90% 적용

**employmentType별 급여 계산 방식**:
1. **근로소득** (시급): 기본급 + 주휴수당 - 4대보험 - 소득세
2. **근로소득** (월급): 월급 - 무급휴가차감 - 4대보험 - 소득세
3. **사업소득** (시급): 기본급 + 주휴수당 - 3.3% 세금
4. **사업소득** (월급): 월급 - 3.3% 세금
5. **일용직**: 시급만, 세금 없음, 주휴수당 없음
6. **외국인**: 시급만, 3.3% 세금, 주휴수당 계산 (사업소득과 동일)

---

### 5. `schedules` - 스케줄
**용도**: 직원별 일별 예정 근무 스케줄

```typescript
{
  id: string;                    // 문서 ID
  employeeId: string;            // 직원 ID
  employeeName: string;          // 직원명 (denormalized)
  branchId: string;              // 지점 ID
  branchName: string;            // 지점명 (denormalized)
  date: Date;                    // 근무일 (예: 2025-09-15)
  
  // 근무시간
  startTime: string;             // 시작시간 (예: "09:00")
  endTime: string;               // 종료시간 (예: "18:00")
  breakTime: number;             // 휴게시간 (시간 단위, 예: 1)
  
  // 계산된 값
  scheduledHours?: number;       // 예정근무시간 (endTime - startTime)
  actualWorkHours?: number;      // 실근무시간 (scheduledHours - breakTime)
  
  weekStart?: Date;              // 해당 주의 시작일 (월요일)
  weekEnd?: Date;                // 해당 주의 종료일 (일요일)
  
  createdAt: Date;
  updatedAt?: Date;
}
```

**주의사항**:
- `date`는 Date 타입으로 저장 (Firestore Timestamp)
- 같은 직원, 같은 날짜, 같은 지점에 중복 스케줄이 없어야 함
- 스케줄 입력 시 다른 지점 스케줄 가져오기 기능 있음 (일요일 포함 주의)

---

### 6. `workTimeComparisonResults` - 근무시간 비교 결과
**용도**: 예정근무시간 vs 실제근무시간 비교 및 확정 데이터

```typescript
{
  id: string;                    // 문서 ID
  employeeId: string;            // 직원 ID
  employeeName: string;          // 직원명
  branchId: string;              // 지점 ID
  branchName: string;            // 지점명
  month: string;                 // "2025-09" 형식
  date: string;                  // "2025-09-15" 형식 또는 Date
  
  // 예정 근무시간 (schedules에서 가져옴)
  scheduledHours: number;        // 예정근무시간 (시간 단위)
  scheduledTimeRange: string;    // 예: "09:00-18:00"
  
  // 실제 근무시간 (사용자가 입력)
  actualHours: number;           // 실제근무시간 (시간 단위)
  actualTimeRange: string;       // 예: "09:05-18:10"
  breakTime: number;             // 휴게시간 (시간 단위)
  actualWorkHours: number;       // 실근무시간 = actualHours - breakTime
  
  // 차이
  difference: number;            // actualHours - scheduledHours
  
  // 상태
  status: string;                // 'time_match' | 'review_required' | 'review_completed'
  
  // 메타데이터
  isModified: boolean;           // 수정 여부
  modifiedAt?: Date;             // 수정 시각
  createdAt: Date;
  updatedAt: Date;
}
```

**중요 로직**:
- **급여계산의 핵심 데이터**: PayrollCalculation은 이 컬렉션에서 `actualWorkHours`를 합산하여 총 근무시간 계산
- `status`:
  - `time_match`: 예정시간과 실제시간이 일치 (자동)
  - `review_required`: 차이가 있어서 검토 필요
  - `review_completed`: 사용자가 "확인완료" 버튼 클릭

**쿼리 예시**:
```typescript
// 특정 직원의 특정 월 데이터 조회
query(
  collection(db, 'workTimeComparisonResults'),
  where('employeeId', '==', employeeId),
  where('month', '==', '2025-09')
)
```

---

### 7. `employeeReviewStatus` - 직원별 검토 상태
**용도**: 직원별 + 지점별 + 월별 근무시간 검토 완료 여부

```typescript
{
  id: string;                    // 문서 ID
  employeeId: string;            // 직원 ID
  branchId: string;              // 지점 ID
  month: string;                 // "2025-09" 형식
  status: string;                // '검토전' | '검토중' | '검토완료'
  updatedAt: Date;
}
```

**중요 로직**:
- 한 직원이 여러 지점에서 근무하면 지점별로 각각 검토 상태 관리
- `검토완료` 상태가 되면 해당 지점의 근무시간 수정 불가
- 급여확정 후에는 수정 완전 불가

**상태 전환**:
```
검토전 → 검토중 (첫 확인완료 시) → 검토완료 (모든 항목 확인완료 시)
```

---

### 8. `employeeMemos` - 직원별 급여메모
**용도**: 직원별 + 월별 급여 관련 메모

```typescript
{
  id: string;                    // 문서 ID
  employeeId: string;            // 직원 ID
  month: string;                 // "2025-09" 형식
  memo: string;                  // 메모 내용
  createdAt: Date;
  updatedAt: Date;
}
```

**주의사항**:
- 한 직원의 한 달에 하나의 메모만 존재
- 급여 계산 화면에서 입력 가능

---

### 9. `confirmedPayrolls` - 급여확정 기록
**용도**: 급여확정 완료된 직원의 최종 급여 데이터

```typescript
{
  id: string;                    // 문서 ID
  employeeId: string;            // 직원 ID
  employeeName: string;          // 직원명
  month: string;                 // "2025-09" 형식
  
  // 직원정보
  residentNumber?: string;       // 주민번호
  bankName?: string;             // 은행명
  bankCode?: string;             // 은행코드
  accountNumber?: string;        // 계좌번호
  accountHolder?: string;        // 예금주명
  
  // 급여정보
  employmentType: string;        // 고용형태
  salaryType: string;            // 급여형태 (시급/월급)
  hourlyWage?: number;           // 시급
  monthlySalary?: number;        // 월급
  totalWorkHours: number;        // 총 근무시간
  actualWorkHours: number;       // 실근무시간
  grossPay: number;              // 지급총액 (기본급 + 주휴수당)
  
  // 공제
  deductions: {
    insurance: number;           // 4대보험 (근로소득만)
    tax: number;                 // 세금
    total: number;               // 총 공제액
    insuranceDetails?: {         // 4대보험 상세
      nationalPension: number;   // 국민연금
      healthInsurance: number;   // 건강보험
      longTermCare: number;      // 장기요양보험
      employmentInsurance: number; // 고용보험
    };
    taxDetails?: {               // 세금 상세
      incomeTax: number;         // 소득세
      localIncomeTax: number;    // 지방소득세
    };
  };
  netPay: number;                // 실수령액
  
  // 지점별 근무시간
  branches: Array<{
    branchId: string;
    branchName: string;
    workHours: number;
  }>;
  
  // 수습기간 정보
  probationHours?: number;       // 수습기간 근무시간
  regularHours?: number;         // 정규 근무시간
  probationPay?: number;         // 수습기간 급여
  regularPay?: number;           // 정규 급여
  
  // 주휴수당
  weeklyHolidayPay?: number;     // 주휴수당 총액
  weeklyHolidayHours?: number;   // 주휴수당 시간
  weeklyHolidayDetails?: Array<{
    weekStart: string;
    weekEnd: string;
    hours: number;
    pay: number;
    eligible: boolean;
  }>;
  
  // 무급휴가 (근로소득+월급만)
  unpaidLeaveDays?: number;      // 무급휴가 일수
  unpaidLeaveDeduction?: number; // 무급휴가 차감액
  
  // 메모
  memo?: string;                 // 비고 (세무사 전송용)
  
  createdAt: Date;
  updatedAt: Date;
}
```

**중요 로직**:
- 급여확정 시 PayrollCalculation에서 계산된 모든 데이터를 여기에 저장
- **급여확정 여부 확인**: 이 컬렉션에 문서가 존재하면 확정됨, 없으면 미확정
- **급여확정 취소**: 해당 문서를 삭제
- 확정 후에는 근무시간비교, 급여계산 모두 수정 불가
- 세무사 전송파일 생성 시 이 컬렉션에서 데이터 조회

**참고**:
- 별도의 `payrollLocks` 컬렉션이나 `status` 필드 없이 문서의 존재 여부만으로 확정 상태 관리
- 이는 가장 심플하고 명확한 방식

---

### 10. `weeklyNotes` - 주간 비고
**용도**: 지점별 + 주간별 비고/메모

```typescript
{
  id: string;                    // 문서 ID
  branchId: string;              // 지점 ID
  branchName: string;            // 지점명
  weekStart: Date;               // 주 시작일 (월요일)
  weekEnd: Date;                 // 주 종료일 (일요일)
  note: string;                  // 비고 내용
  createdAt: Date;
  updatedAt: Date;
}
```

**주의사항**:
- 같은 지점의 같은 주간에 하나의 비고만 존재해야 함
- 저장 시 기존 문서 존재 여부 체크 후 update/add 분기

---

### 11. `bankCodes` - 은행코드
**용도**: 은행명-은행코드 매핑

```typescript
{
  id: string;                    // 문서 ID
  code: string;                  // 은행코드 (예: "004")
  name: string;                  // 은행명 (예: "KB국민은행")
}
```

---

## 🏗️ 컴포넌트 구조

### 1. `EmployeePayrollProcessing.tsx` (최상위)
**역할**: 직원별 급여처리 진입점, 직원 목록 + 탭 관리

**주요 상태**:
```typescript
- employees: Employee[]           // 직원 목록
- contracts: Contract[]           // 근로계약 목록
- selectedEmployeeId: string      // 선택된 직원 ID
- selectedMonth: string           // 선택된 월 (YYYY-MM)
- activeTab: 'work-comparison' | 'payroll-calculation'
```

**주요 로직**:
1. `loadContracts()`: 선택된 월에 유효한 근로계약만 로드
2. `loadEmployees()`: 유효한 계약이 있는 직원만 필터링
3. 직원 선택 시 `selectedEmployeeId` 업데이트 → 하위 컴포넌트로 전달

**문제점**:
- `useEffect` 의존성 배열이 복잡하여 무한루프 발생 가능
- `loadEmployees`와 `loadContracts` 호출 순서에 의존

**개선방향**:
```typescript
// 명확한 데이터 로딩 순서
useEffect(() => {
  if (selectedMonth) {
    loadContracts();  // 1. 계약 로드
  }
}, [selectedMonth]);

useEffect(() => {
  if (contracts.length > 0) {
    loadEmployees();  // 2. 계약 로드 완료 후 직원 로드
  }
}, [contracts]);
```

---

### 2. `WorkTimeComparison.tsx`
**역할**: 근무시간 비교 및 확정

**주요 상태**:
```typescript
- comparisonResults: ComparisonResult[]  // 비교 결과 목록
- employeeReviewStatus: ReviewStatus[]   // 검토 상태
- selectedBranchId: string               // 선택된 지점
```

**주요 로직**:
1. `loadComparisonData()`: schedules + workTimeComparisonResults 조회
   - schedules에서 예정근무시간 가져오기
   - workTimeComparisonResults에 기존 데이터가 있으면 사용, 없으면 schedules로 초기화
2. `handleConfirm()`: 개별 항목 확인완료
   - workTimeComparisonResults의 status를 'review_completed'로 업데이트
3. `handleCompleteReview()`: 지점별 전체 검토완료
   - employeeReviewStatus를 '검토완료'로 업데이트

**중요한 조건**:
- 검토완료 상태에서는 수정 불가
- 급여확정 후에는 완전히 수정 불가

---

### 3. `PayrollCalculation.tsx`
**역할**: 급여 계산 및 확정

**주요 상태**:
```typescript
- employees: Employee[]                 // 직원 목록
- weeklySchedules: WeeklySchedule[]     // 주간 스케줄 (workTimeComparisonResults)
- payrollCalculations: PayrollCalculation[]  // 계산 결과
```

**주요 로직**:
1. `loadSchedules()`: workTimeComparisonResults에서 실근무시간 조회
   ```typescript
   query(
     collection(db, 'workTimeComparisonResults'),
     where('month', '==', selectedMonth),
     where('employeeId', '==', selectedEmployeeId)
   )
   ```

2. `calculatePayroll()`: 급여 계산 핵심 로직
   ```typescript
   // 의사코드
   for (직원별) {
     // 1. 계약정보 가져오기
     contract = employmentContracts에서 유효한 계약 찾기
     
     // 2. 실근무시간 합산
     totalWorkHours = workTimeComparisonResults의 actualWorkHours 합산
     
     // 3. 수습기간 구분
     if (수습기간 정보 있음) {
       schedules를 순회하며:
         if (schedule.date가 수습기간 내) {
           probationHours += actualWorkHours
         } else {
           regularHours += actualWorkHours
         }
     }
     
     // 4. 기본급 계산
     if (시급제) {
       기본급 = (probationHours * 시급 * 0.9) + (regularHours * 시급)
     } else if (월급제) {
       기본급 = 월급 (또는 월급 * 0.9)
       무급휴가 차감 로직
     }
     
     // 5. 주휴수당 계산 (시급제만, 주휴수당 포함 안된 경우만)
     if (시급제 && !includesWeeklyHolidayInWage) {
       주휴수당 = calcWeeklyHolidayPay(...)
     }
     
     // 6. 공제 계산
     if (근로소득) {
       4대보험 = 국민연금 + 건강보험 + 장기요양 + 고용보험
       소득세 = 간이세액표
       지방소득세 = 소득세 * 0.1
     } else if (사업소득 || 외국인) {
       세금 = 기본급 * 0.033
     }
     
     // 7. 실수령액
     실수령액 = 기본급 + 주휴수당 - 4대보험 - 세금
   }
   ```

3. `handleConfirmPayroll()`: 급여확정
   - confirmedPayrolls에 저장
   - payrollLocks에 잠금 설정

**문제점**:
1. `useEffect`와 `useCallback` 의존성 배열 문제로 무한루프
2. 데이터 로딩 순서 불명확 (employees, schedules, contracts 누가 먼저?)
3. 계산 로직이 너무 길고 복잡 (500줄 이상)

**개선방향**:
```typescript
// 1. 데이터 로딩을 순차적으로
useEffect(() => {
  if (!selectedMonth || !selectedEmployeeId) return;
  
  async function loadAllData() {
    setLoading(true);
    try {
      const [emp, contracts, schedules] = await Promise.all([
        loadEmployees(),
        loadContracts(),
        loadSchedules()
      ]);
      // 데이터 로드 완료 후 계산
      calculatePayroll(emp, contracts, schedules);
    } finally {
      setLoading(false);
    }
  }
  
  loadAllData();
}, [selectedMonth, selectedEmployeeId]);

// 2. 계산 로직 분리
function calculateBasePay(employee, contract, workHours) { ... }
function calculateProbation(employee, contract, schedules) { ... }
function calculateWeeklyHoliday(employee, contract, schedules) { ... }
function calculateDeductions(employee, contract, grossPay) { ... }
```

---

## 🔄 데이터 흐름

### 근무시간 → 급여계산 흐름
```
1. schedules 컬렉션
   ├─> 예정근무시간 (scheduledHours, breakTime)
   └─> WorkTimeComparison에서 로드

2. WorkTimeComparison
   ├─> 실제근무시간 입력 (actualHours, actualWorkHours)
   └─> workTimeComparisonResults에 저장
       └─> status: time_match / review_required / review_completed

3. employeeReviewStatus
   └─> 지점별 검토완료 여부 (검토전/검토중/검토완료)

4. PayrollCalculation
   ├─> workTimeComparisonResults에서 actualWorkHours 조회
   ├─> employmentContracts에서 계약정보 조회
   ├─> 급여 계산 (기본급, 수습, 주휴수당, 공제)
   └─> 확정 시 confirmedPayrolls에 저장

5. TaxFileGeneration
   └─> confirmedPayrolls에서 확정된 급여 조회
       └─> 엑셀 파일 생성
```

---

## 📊 주요 계산 로직

### 1. 수습기간 계산
```typescript
// 수습기간 판단
const isProbation = (date: Date) => {
  if (!probationStartDate || !probationEndDate) return false;
  const dateOnly = new Date(date.toISOString().split('T')[0]);
  const startOnly = new Date(probationStartDate.toISOString().split('T')[0]);
  const endOnly = new Date(probationEndDate.toISOString().split('T')[0]);
  return dateOnly >= startOnly && dateOnly <= endOnly;
}

// 수습기간 시급 적용
수습기간_급여 = 수습기간_근무시간 * 시급 * 0.9
정규_급여 = 정규_근무시간 * 시급
```

**주의사항**:
- 날짜 비교 시 시간 제거 (YYYY-MM-DD만 비교)
- Firestore Timestamp → Date 변환 필수

---

### 2. 주휴수당 계산
```typescript
// 조건
1. 시급제여야 함
2. includesWeeklyHolidayInWage가 false여야 함
3. 고용형태가 '근로소득', '사업소득', '외국인'이어야 함
4. 해당 주에 스케줄된 모든 날 출근해야 함

// 계산
주휴수당_시간 = (주간계약시간 / 주간근무일수) * 1일
주휴수당_금액 = 주휴수당_시간 * 시급
```

**로직**:
- `calcWeeklyHolidayPay()` 함수 사용
- 주차별로 계산하여 합산
- 첫째주는 전주 출근 여부도 확인

---

### 3. 4대보험 계산 (근로소득자만)
```typescript
// 2025년 기준
국민연금 = 지급총액 * 0.045      // 4.5%
건강보험 = 지급총액 * 0.03545    // 3.545%
장기요양보험 = 건강보험 * 0.1295 // 건강보험의 12.95%
고용보험 = 지급총액 * 0.009      // 0.9%

4대보험_합계 = 국민연금 + 건강보험 + 장기요양보험 + 고용보험
```

---

### 4. 소득세 계산 (근로소득자만)
```typescript
// 간이세액표 (부양가족 1명 기준)
if (월급 <= 1,060,000) {
  소득세 = 0
} else if (월급 <= 2,100,000) {
  소득세 = (월급 - 1,060,000) * 0.02
} else if (월급 <= 3,160,000) {
  소득세 = 20,800 + (월급 - 2,100,000) * 0.04
} else if (월급 <= 5,000,000) {
  소득세 = 63,200 + (월급 - 3,160,000) * 0.06
} else {
  소득세 = 173,600 + (월급 - 5,000,000) * 0.08
}

지방소득세 = 소득세 * 0.1
```

---

### 5. 사업소득세 계산 (사업소득자, 외국인)
```typescript
세금 = (기본급 + 주휴수당) * 0.033  // 3.3%
```

---

### 6. 무급휴가 차감 (근로소득자 + 월급제만)
```typescript
일할_급여 = 월급 / 30일
무급휴가_차감 = 일할_급여 * 무급휴가_일수
기본급 = 월급 - 무급휴가_차감
```

---

## ⚠️ 문제점 및 개선방향

### 현재 문제점

#### 1. 무한루프 문제
**원인**:
```typescript
// PayrollCalculation.tsx
const calculatePayroll = useCallback(() => {
  // ... 계산 로직 ...
  setPayrollCalculations(결과);  // state 변경
}, [employees, weeklySchedules]);  // employees, weeklySchedules 의존

useEffect(() => {
  calculatePayroll();
}, [selectedEmployeeId, employees, weeklySchedules, calculatePayroll]);
// calculatePayroll이 변경되면 다시 실행 → 무한루프
```

**해결방법**:
```typescript
// 방법 1: useCallback 의존성 최소화
const calculatePayroll = useCallback(() => {
  // ...
}, [selectedEmployeeId]);  // 직원 ID만 의존

// 방법 2: useEffect에서 직접 계산
useEffect(() => {
  if (!employees.length || !selectedEmployeeId) return;
  
  // 계산 로직을 여기에 직접 작성 (useCallback 사용 안함)
  const result = ...;
  setPayrollCalculations(result);
}, [selectedEmployeeId, employees, weeklySchedules]);
```

---

#### 2. 데이터 로딩 순서 불명확
**문제**:
- employees, contracts, weeklySchedules가 각각 다른 타이밍에 로드
- 어떤 데이터가 먼저 필요한지 불명확

**해결방법**:
```typescript
// 1. 순차적 로딩
async function loadPayrollData() {
  setLoading(true);
  try {
    // 1단계: 기본 데이터
    const [branches, employees] = await Promise.all([
      loadBranches(),
      loadEmployees()
    ]);
    
    // 2단계: 선택된 직원의 계약 및 근무시간
    if (selectedEmployeeId && selectedMonth) {
      const [contracts, schedules] = await Promise.all([
        loadContracts(selectedEmployeeId, selectedMonth),
        loadSchedules(selectedEmployeeId, selectedMonth)
      ]);
      
      // 3단계: 계산
      const result = calculatePayroll(employees, contracts, schedules);
      setPayrollCalculations([result]);
    }
  } finally {
    setLoading(false);
  }
}
```

---

#### 3. 계산 로직이 한 함수에 집중
**문제**:
- `calculatePayroll()` 함수가 500줄 이상
- 수습, 주휴수당, 4대보험, 세금 계산이 모두 섞여있음

**해결방법**:
```typescript
// 계산 로직 분리
class PayrollCalculator {
  constructor(employee, contract, schedules) {
    this.employee = employee;
    this.contract = contract;
    this.schedules = schedules;
  }
  
  // 1. 근무시간 계산
  calculateWorkHours() {
    const total = this.schedules.reduce((sum, s) => sum + s.actualWorkHours, 0);
    return total;
  }
  
  // 2. 수습기간 구분
  separateProbationHours() {
    const probationHours = 0;
    const regularHours = 0;
    // ...
    return { probationHours, regularHours };
  }
  
  // 3. 기본급 계산
  calculateBasePay({ probationHours, regularHours }) {
    if (this.contract.salaryType === 'hourly') {
      return probationHours * this.contract.salaryAmount * 0.9
           + regularHours * this.contract.salaryAmount;
    } else {
      return this.contract.salaryAmount;  // 월급
    }
  }
  
  // 4. 주휴수당 계산
  calculateWeeklyHoliday() {
    // ...
  }
  
  // 5. 공제 계산
  calculateDeductions(grossPay) {
    if (this.contract.employmentType === '근로소득') {
      return this.calculateInsuranceAndTax(grossPay);
    } else {
      return this.calculateBusinessTax(grossPay);
    }
  }
  
  // 최종 계산
  calculate() {
    const workHours = this.calculateWorkHours();
    const { probationHours, regularHours } = this.separateProbationHours();
    const basePay = this.calculateBasePay({ probationHours, regularHours });
    const weeklyHoliday = this.calculateWeeklyHoliday();
    const grossPay = basePay + weeklyHoliday;
    const deductions = this.calculateDeductions(grossPay);
    const netPay = grossPay - deductions.total;
    
    return {
      basePay,
      weeklyHoliday,
      grossPay,
      deductions,
      netPay,
      // ...
    };
  }
}
```

---

#### 4. 타입스크립트 타입 불일치
**문제**:
- `schedule.date`가 때로는 `string`, 때로는 `Date`, 때로는 `Timestamp`
- 타입 단언 (`as Date`) 남발

**해결방법**:
```typescript
// 1. 명확한 타입 정의
interface Schedule {
  id: string;
  employeeId: string;
  date: Date;  // 항상 Date 타입
  // ...
}

// 2. Firestore에서 로드할 때 변환
const schedules = schedulesSnapshot.docs.map(doc => {
  const data = doc.data();
  return {
    id: doc.id,
    ...data,
    date: data.date?.toDate ? data.date.toDate() : new Date(data.date),
    // 모든 Date 필드를 명시적으로 변환
  };
});
```

---

### 권장 개선 방향

#### 1. 컴포넌트 재구성
```
EmployeePayrollProcessing (최상위)
├─ EmployeeList (직원 목록)
│  └─ 직원 선택 → selectedEmployeeId 업데이트
├─ PayrollTabs (탭 전환)
│  ├─ WorkTimeComparisonTab
│  │  └─ WorkTimeComparison 컴포넌트
│  └─ PayrollCalculationTab
│     ├─ PayrollDataLoader (데이터 로딩 전용)
│     ├─ PayrollCalculator (계산 로직 전용)
│     └─ PayrollDisplay (결과 표시 전용)
```

#### 2. 데이터 로딩 전용 훅 작성
```typescript
// hooks/usePayrollData.ts
export function usePayrollData(employeeId: string, month: string) {
  const [loading, setLoading] = useState(false);
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    if (!employeeId || !month) return;
    
    let cancelled = false;
    
    async function load() {
      setLoading(true);
      try {
        const employee = await loadEmployee(employeeId);
        const contract = await loadContract(employeeId, month);
        const schedules = await loadSchedules(employeeId, month);
        
        if (!cancelled) {
          setData({ employee, contract, schedules });
        }
      } catch (err) {
        if (!cancelled) {
          setError(err);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    }
    
    load();
    
    return () => { cancelled = true; };
  }, [employeeId, month]);
  
  return { data, loading, error };
}
```

#### 3. 계산 로직을 별도 유틸리티로 분리
```typescript
// utils/payrollCalculator.ts
export class PayrollCalculator {
  // ... (위에서 설명한 클래스)
}

// 컴포넌트에서 사용
import { PayrollCalculator } from '@/utils/payrollCalculator';

const calculator = new PayrollCalculator(employee, contract, schedules);
const result = calculator.calculate();
```

---

## 📝 체크리스트

### 급여 계산 전 필수 확인사항
- [ ] 직원의 입사일/퇴사일이 올바른가?
- [ ] 해당월에 유효한 근로계약이 존재하는가?
- [ ] 근로계약의 고용형태, 급여형태, 급여액이 올바른가?
- [ ] 수습기간 정보가 정확한가?
- [ ] 주휴수당 포함 여부가 올바른가?
- [ ] 모든 지점의 근무시간비교가 '검토완료'인가?
- [ ] workTimeComparisonResults에 실근무시간 데이터가 있는가?

### 급여 확정 전 필수 확인사항
- [ ] 계산된 급여가 올바른가?
- [ ] 수습기간 적용이 올바른가?
- [ ] 주휴수당 계산이 올바른가?
- [ ] 4대보험/세금 계산이 올바른가?
- [ ] 은행정보가 입력되어 있는가?
- [ ] 주민번호가 입력되어 있는가?

---

## 🎯 결론

### 핵심 문제 요약
1. **무한루프**: useEffect/useCallback 의존성 배열 문제
2. **데이터 로딩 순서**: 어떤 데이터가 먼저 필요한지 불명확
3. **복잡한 계산 로직**: 한 함수에 모든 로직 집중
4. **타입 불일치**: Date/string/Timestamp 혼용

### 해결 방향
1. **명확한 데이터 흐름**: 순차적 로딩 (employees → contracts → schedules → calculate)
2. **계산 로직 분리**: 클래스 또는 여러 함수로 분리
3. **타입 안정성**: Firestore에서 로드할 때 즉시 Date로 변환
4. **단순한 의존성**: useCallback 최소화, useEffect 명확화

이 문서를 바탕으로 급여처리 시스템을 개선하시면 더 안정적으로 동작할 것입니다!

